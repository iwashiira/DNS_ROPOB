DNS_ROPOB
===============

# 概要
* [ROPOB: Obfuscating Binary Code
via Return Oriented Programming](https://mudongliang.github.io/files/papers/ropob_securecomm.pdf)という論文を参考に、TSG LIVE CTF 8のために作ったプログラム。汚いコードなのは許してほしい。(時間があれば綺麗にする。)
* `input/dns_ropob.c`が問題のソースコード

# 論文との相違点。

* 論文ではバイナリに対して変更を施していたが、.sファイルに対して変更を施すようにした。
  * これにより、相対アドレッシングのアドレス解決が簡単になった。
* 論文ではガジェットからガジェットへとオフセットテーブルを参照しながらretを介して飛んでいくようにしたようだが、リゾルバ関数を作ってそこを経由するようにした。
  * 次のガジェットの前に別の関数を迂回するということで、すべてのレジスタの値が完全に保存されている状態で次のガジェットへとたどり着く必要がある。
  * pushfqを二回行ってreturnアドレスの格納用の領域を作ったのは多分オリジナル?
* 論文では多分機械語の長さの取得は独自のプログラムでやったのだろうが、面倒だったのでobjdumpを使って読み取るようにした。
  * ガジェット化に伴ってJMP命令のアドレッシングの距離が変化してしまうが故に、ソースコードから作られた.sファイルからアセンブルリンクされてできるexecutableと、ガジェット化が施された.sファイルからアセンブルリンクされてできるexecutableの機械語長が一致しない問題は、JMP命令の長さの計算だけ正しくない.sファイルを作ってアセンブルリンクして作り出したexecutableからさらにobjdumpすることで、正しいJMP命令の長さを計算することで解決した。(かなりのゴリ押し)
 
# 制約

* x86_64のELFバイナリのみ作り出せる。
* objdumpとgccに依存している。

# 使い方

```
make
./dns_ropob_generator hogehoge.c
```
