DNS_ROPOB
===============

# 概要
* [ROPOB: Obfuscating Binary Code
via Return Oriented Programming](https://mudongliang.github.io/files/papers/ropob_securecomm.pdf)という論文を参考に、TSG LIVE CTF 8のために作ったプログラム。汚いコードなのは許してほしい。(時間があれば綺麗にする。)
* `input/dns_ropob.c`が問題のソースコード
* どのような仕組みかは、変換後のバイナリをstep実行すれば自ずとわかる。
* 論文と同じく、動的解析には無力

# 論文との相違点。

* 論文ではバイナリに対して変更を施していたが、.sファイルに対して変更を施すようにした。
  * これにより、相対アドレッシングのアドレス解決が簡単になった。
* 論文ではガジェットからガジェットへとオフセットテーブルを参照しながらretを介して飛んでいくようにしたようだが、リゾルバ関数を作ってそこを経由するようにした。
  * 次のガジェットの前に別の関数を迂回するということで、すべてのレジスタの値が完全に保存されている状態で次のガジェットへとたどり着く必要がある。
  * pushfqを二回行ってreturnアドレスの格納用の領域を作ったのは多分オリジナル?
* 論文では多分機械語の長さの取得は独自のプログラムでやったのだろうが、面倒だったのでobjdumpを使って読み取るようにした。
  * ガジェット化に伴ってJMP命令のアドレッシングの距離が変化してしまうが故に、ソースコードから作られた.sファイルからアセンブルリンクされてできるexecutableと、ガジェット化が施された.sファイルからアセンブルリンクされてできるexecutableの機械語長が一致しない問題は、JMP命令の長さの計算だけ正しくない.sファイルを作ってアセンブルリンクして作り出したexecutableからさらにobjdumpすることで、正しいJMP命令の長さを計算するというかなりのゴリ押しで解決した。
 
# 制約

* x86_64のELFバイナリのみ作り出せる。
* objdumpとgccに依存している。

# 使い方

```
make
./dns_ropob_generator hogehoge.c
```
# 以下細かい説明

## ガジェットからガジェットへの遷移の実現のための課題。
1. ガジェットからガジェットへの行き来のためには次に到達すべきガジェットのアドレスを知る必要がある。
2. 特定の命令がちゃんと動く必要がある。push pop leave call jmp cmp ret等

方針
* functionに番号をふり、その中のガジェットにも番号をふる。
* JMP系命令 => そのまま実行
* それ以外 => resolver()を作ってそれに頼る。
  * resolver()を作るメリットとしては、ガジェットはresolver()にretして移動するだけでよく、resolver()はガジェットのオフセットテーブルを適切に作ることができれば、それを見て次のガジェットに簡単にretできる。つまり、ガジェット自身の中で次のガジェットへと移動するための複雑な機構を設ける必要はなく、最低限のfunctionの番号とその中のガジェット自身の番号さえresolverに渡せれば良い。今回はそれに加えfunctionのbaseアドレスも渡すようにした。
    - retを使うので、(工夫すればできるけれど)stack渡しはしない。グローバル変数等を使う。
